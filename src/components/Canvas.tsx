import { FC, useEffect, useState } from 'react'
import Sketch from 'react-p5'
import P5 from 'p5'
import { computeFourierSeries, functionFromPoints } from '../computations'
import math, { add, Complex, subsetTransformDependencies } from 'mathjs'
import _ from 'lodash'

type CanvasProps = { 
    mode: string, 
    setMode: (m: string) => void,
    lineColor: string, 
    points: Array<[number, number]>,
    setPoints: (points: [number, number][]) => void
}

type FourierCoefficients = (t: number) => Complex[]

const Canvas: FC<CanvasProps> = props => {

    const step = 0.001
    const [n, setN] = useState<number>(25)
    const [t, setT] = useState<number>(0)
    const [fourierCoefficients, setFourierCoefficients] = useState <FourierCoefficients>(() => () => [])
    const [fourierComputedPoints, setFourierComputedPoints] = useState<Array<[number, number]>>([])
    const [addToFourierComputedPoints, setAddToFourierComputedPoints] = useState<boolean>(true)

    /**
     * Setup P5 Sketch 
     * @param p5 
     * @param parentRef 
     */
    const setup = (p5: P5, parentRef: Element ) => {
        p5.createCanvas(window.innerWidth, window.innerHeight).parent(parentRef);
        p5.frameRate(60)
    }

    /**
     * Draw function for P5 sketch, updates on an infinite loop
     * @param p5 
     */
    const draw = (p5: P5) => {
        // input mode: allow user to draw using cursor
        if (props.mode === 'input') {
            p5.stroke(props.lineColor)

            if (p5.mouseIsPressed === true && (p5.mouseX > 160 || p5.mouseY > 40)) {
                props.setPoints(addToPoints([p5.mouseX, p5.mouseY]))
                p5.line(p5.mouseX, p5.mouseY, p5.pmouseX, p5.pmouseY);
            }
        } else if (props.mode === 'animate') {
            // plot inputted line
            plotPoints(p5, props.points, props.lineColor)

            // get fourier coeffs            
            let fourier_t = fourierCoefficients(t)

            // add to the line generated by the fourier series if it has not yet been fully created
            if (addToFourierComputedPoints) {
                const endpoint = fourier_t.reduce((a, b) => add(a, b))
                setFourierComputedPoints((fourierComputedPoints: Array<[number, number]>) => [...fourierComputedPoints, [endpoint.re, endpoint.im]])
            }
            
            // plot the line generate so far by the fourier series
            plotPoints(p5, fourierComputedPoints, '#aa5151')

            /*
            Render lines for each vector in the Fourier series
            */
            // set starting point to 0, 0
            let [lx1, ly1] = centreCoords(0, 0) as [number, number]

            for (const i of _.range(n, 0, -1).map(m => Math.pow(-1, m + 1) * Math.floor(m / 2))) {
                const vector = fourier_t[i < 0 ? fourier_t.length + i : i]

                let [lx2, ly2] = [vector.re + lx1, vector.im + ly1] as [number, number]

                [lx1, ly1] = centreCoords(lx1, ly1) as [number, number]
                [lx2, ly2] = centreCoords(lx2, ly2) as [number, number]
                p5.stroke('#929292')
                p5.line(lx1, ly1, lx2, ly2)

                lx1 = lx2
                ly1 = ly2
            }
            
            setT(t >= 1 ? 0 : t + step)

        }
    }


    const centreCoords = (x: number, y: number): [number, number] => {
        return [x + window.innerWidth / 2, -y + window.innerHeight / 2] as [number, number]
    }

    /**
     * Appends <p> to <props.points> because an anonymous function doesn't seem to work
     * @param p 
     * @returns [number, number][] original array with <p> appended
     */
    const addToPoints = (p: [number, number]) => {
        return [...props.points, p]
    }
    
    /**
     * Update Sketch dimensions on windowResize event 
     * @param p5 
     */
    const windowResized = (p5: P5) => {
        p5.resizeCanvas(window.innerWidth, window.innerHeight);

        // render the line because canvas gets cleared on resize
        plotPoints(p5, props.points, props.lineColor)
    }

    const plotPoints = (p5: P5, points: Array<[number, number]>, lineColor: string) => {
        p5.stroke(lineColor)
        p5.strokeWeight(1)
        for (let i = 1; i < points.length; i++) {
            p5.line(points[i - 1][0], points[i - 1][1], points[i][0], points[i][1])
        }
    }




    useEffect(() => {
        if (props.mode === 'processing') {
            const f = computeFourierSeries(
                n,
                functionFromPoints(props.points)
            )
            setFourierCoefficients(() => (t: number) => f(t))
            props.setMode('animate')
        }
    }, [fourierCoefficients, props])
  

    // return <canvas ref={canvasRef}/>
    return <Sketch setup={setup} draw={draw} windowResized={windowResized} />
}

export default Canvas